'''python中的数据类型
   1、整数：于数学中的整数一样，有正有负，无大小限制
   表现形式：十进制-默认010
            二进制-0B/b010
            八进制-0O/o010
            十六进制-0X/x010
    最常用函数，pow（x,y）x的y次幂，同样可以嵌套，pow(2,pow(2,3))
    2、浮点数：用二进制表示小数，之间的换算不是百分百，即存在误差，这部分称之为不确定尾数
              具体表示为，0.1+0.2！=0.3
              值得注意的是round(x,n),x为四舍五入的数，n为保留几位小数，只考虑第n+1位小数的值是否满足四舍五入
              科学计数法，<a>e/E<b>,这个表示a*（10的b次方）如4.3e-3、9.6E5
    3、复数：于数学中复数概念一致,但虚部符号表示为j
       z=1.23e-4+5.6e+89j,此时z就是一个复数，可以用z.real获得实部，z.imag获得虚部。
       通常而言，其实复数用到的地方不多，但是...还是需要记住的勒。
    4、"=="表示相等，"!="表示不等
    5、操作符：完成数据运算的一种的操作体系
       +： x+y,   和
       -： x-y,   差
       *： x*y,   乘
       /： x/y,   除   在python中，除法得到的是一个浮点数。没错，即使是两个整数相除，得到依然是浮点数，改变了数据类型。
       //：x//y， 整除
       +： +x,    x本身
       -： -x,    x的负值
       %： x%y,   模运算，求余
       **：x**y,  x^y次方，y=0.5时，就是求根
       上述的二元操作符，均具有增强赋值操作符形式，即对两个数据计算后修改其中一个。
       如：+=、-+、x**=y、//=、%=...
       注：如果是不同类型数据间运算，那么得到的最终结果是最宽的一个。整数->浮点数->复数。
    6、运算函数：以函数形式提供数据运算的功能。
       abs(x):       x的绝对值
       divmod(x,y):  (x//y,x%y) 如divmod(10,3)输出(3,1)
       pow(x,y[,z]): (x**y)%z  注意[..]表示参数z可忽略，如pow(3,pow(3,99),10000)得到其最后四位数。加入z过后，可以使得，无
       论前面是多大的次方，可以将其限制在z大小附近，得到我们想要的余数
       round(x[,d]):  四舍五入，d是保留小数位位数，默认值为0
       max(x1,x2,...xn): 得到最大值,数据类型相同。
       min(x1,x2,...xn): 得到最小值,数据类型相同。
    7、类型转换函数：int(x)、float(x)、complex(x),转换为整数、浮点数、复数。
       注意的是，int()、float()可以将字符串转换为相应数字，但这个字符串格式不能有除数字外其它符号。
  
        
 '''
# 这个列表的值，很奇怪。
# print(max([1,4],[2,3]))
# print(int("1s"))

# # DayDayUpQ1.py 天天向上的力量
# dayfactor=0.01
# dayup=pow(1+dayfactor,365)
# daydown=pow(1-dayfactor,365)
# print("向上：{:.2f} 向下：{:.2f}".format(dayup,daydown))

# # 工作日的力量
# dayup=1
# dayfactor=0.01
# for i in range(365):
#     if i % 7 in [5,6]:
#         dayup *= (1-dayfactor)
#     else:
#         dayup *= (1+dayfactor)
# print("最终提升的结果：{:.2f}".format(dayup))

# # 工作日的追赶
# # 在如今计算机算力的飞速提升下，程序思维中抽象于自动化的部分，作用逐渐凸显，简而言之，
# # 将具体问题化为抽象的各个步骤，再用计算机自动处理这些
# def dayUP(dayfactor):
#     dayup=1
#     for i in range(365):
#         if i % 7 in [5,6]:
#             dayup *= (1-0.001)
#         else:
#             dayup *= (1+dayfactor)
#     return dayup
# temp=pow(1.001,365)
# dayfactor=0.001
# while dayUP(dayfactor)<temp:
#     dayfactor+=0.0001
# print("最终提升的结果：{:.4f}".format(dayfactor))
